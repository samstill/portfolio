import{$ as h,_ as f,t as u,i as o,c as i,V as m,h as n,v as g,U as y,x as l,K as p,z as U,w as D}from"./index-I4BBwYdS.js";class a extends Error{constructor(e){super(e),this.name="UnauthorizedError"}}const R={async createMessage(r){try{const e={content:r,timestamp:h(),isRead:!1,createdAt:h()};return(await f(u(o,"anonymous_messages"),e)).id}catch(e){throw console.error("Error sending message:",e),e}},async getAllMessages(){var r;try{const e=i.currentUser;if(!e)throw new a("User must be authenticated");const s=await m(n(o,"users",e.uid));if(!s.exists()||((r=s.data())==null?void 0:r.role)!=="admin")throw new a("Only admin users can view messages");const t=g(u(o,"anonymous_messages"),y("timestamp","desc"));return(await l(t)).docs.map(d=>{var w;return{id:d.id,...d.data(),timestamp:(w=d.data().timestamp)==null?void 0:w.toDate()}})}catch(e){throw console.error("Error fetching messages:",e),e instanceof a?e:new Error("Failed to fetch messages")}},async markAsRead(r){var e;try{const s=i.currentUser;if(!s)throw new a("User must be authenticated");const t=await m(n(o,"users",s.uid));if(!t.exists()||((e=t.data())==null?void 0:e.role)!=="admin")throw new a("Only admin users can mark messages as read");const c=n(o,"anonymous_messages",r);await p(c,{isRead:!0})}catch(s){throw console.error("Error marking message as read:",s),s instanceof a?s:new Error("Failed to mark message as read")}},async deleteMessage(r){var e;try{const s=i.currentUser;if(!s)throw new a("User must be authenticated");const t=await m(n(o,"users",s.uid));if(!t.exists()||((e=t.data())==null?void 0:e.role)!=="admin")throw new a("Only admin users can delete messages");const c=n(o,"anonymous_messages",r);await U(c)}catch(s){throw console.error("Error deleting message:",s),s instanceof a?s:new Error("Failed to delete message")}},async getUnreadCount(){var r;try{const e=i.currentUser;if(!e)throw new a("User must be authenticated");const s=await m(n(o,"users",e.uid));if(!s.exists()||((r=s.data())==null?void 0:r.role)!=="admin")throw new a("Only admin users can view message counts");const t=g(u(o,"anonymous_messages"),D("isRead","==",!1));return(await l(t)).size}catch(e){if(console.error("Error getting unread count:",e),e instanceof a)throw e;return 0}}};export{R as m};
